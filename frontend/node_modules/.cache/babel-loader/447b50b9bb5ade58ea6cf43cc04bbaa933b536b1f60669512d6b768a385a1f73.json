{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport React, { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { drag } from 'd3-drag';\nimport { select } from 'd3-selection';\nimport { useNodeId, useStoreApi, useGetPointerPosition, clamp } from '@reactflow/core';\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n  ResizeControlVariant[\"Line\"] = \"line\";\n  ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\n\n// returns an array of two numbers (0, 1 or -1) representing the direction of the resize\n// 0 = no change, 1 = increase, -1 = decrease\nfunction getDirection(_ref) {\n  let {\n    width,\n    prevWidth,\n    height,\n    prevHeight,\n    invertX,\n    invertY\n  } = _ref;\n  const deltaWidth = width - prevWidth;\n  const deltaHeight = height - prevHeight;\n  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n  if (deltaWidth && invertX) {\n    direction[0] = direction[0] * -1;\n  }\n  if (deltaHeight && invertY) {\n    direction[1] = direction[1] * -1;\n  }\n  return direction;\n}\nconst initPrevValues = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0\n};\nconst initStartValues = _objectSpread(_objectSpread({}, initPrevValues), {}, {\n  pointerX: 0,\n  pointerY: 0,\n  aspectRatio: 1\n});\nfunction ResizeControl(_ref2) {\n  let {\n    nodeId,\n    position,\n    variant = ResizeControlVariant.Handle,\n    className,\n    style = {},\n    children,\n    color,\n    minWidth = 10,\n    minHeight = 10,\n    maxWidth = Number.MAX_VALUE,\n    maxHeight = Number.MAX_VALUE,\n    keepAspectRatio = false,\n    shouldResize,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  } = _ref2;\n  const contextNodeId = useNodeId();\n  const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n  const store = useStoreApi();\n  const resizeControlRef = useRef(null);\n  const startValues = useRef(initStartValues);\n  const prevValues = useRef(initPrevValues);\n  const getPointerPosition = useGetPointerPosition();\n  const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';\n  const controlPosition = position !== null && position !== void 0 ? position : defaultPosition;\n  useEffect(() => {\n    if (!resizeControlRef.current || !id) {\n      return;\n    }\n    const selection = select(resizeControlRef.current);\n    const enableX = controlPosition.includes('right') || controlPosition.includes('left');\n    const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const invertX = controlPosition.includes('left');\n    const invertY = controlPosition.includes('top');\n    const dragHandler = drag().on('start', event => {\n      var _node$width, _node$height, _node$position$x, _node$position$y;\n      const node = store.getState().nodeInternals.get(id);\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event);\n      prevValues.current = {\n        width: (_node$width = node === null || node === void 0 ? void 0 : node.width) !== null && _node$width !== void 0 ? _node$width : 0,\n        height: (_node$height = node === null || node === void 0 ? void 0 : node.height) !== null && _node$height !== void 0 ? _node$height : 0,\n        x: (_node$position$x = node === null || node === void 0 ? void 0 : node.position.x) !== null && _node$position$x !== void 0 ? _node$position$x : 0,\n        y: (_node$position$y = node === null || node === void 0 ? void 0 : node.position.y) !== null && _node$position$y !== void 0 ? _node$position$y : 0\n      };\n      startValues.current = _objectSpread(_objectSpread({}, prevValues.current), {}, {\n        pointerX: xSnapped,\n        pointerY: ySnapped,\n        aspectRatio: prevValues.current.width / prevValues.current.height\n      });\n      onResizeStart === null || onResizeStart === void 0 || onResizeStart(event, _objectSpread({}, prevValues.current));\n    }).on('drag', event => {\n      const {\n        nodeInternals,\n        triggerNodeChanges\n      } = store.getState();\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event);\n      const node = nodeInternals.get(id);\n      if (node) {\n        const changes = [];\n        const {\n          pointerX: startX,\n          pointerY: startY,\n          width: startWidth,\n          height: startHeight,\n          x: startNodeX,\n          y: startNodeY,\n          aspectRatio\n        } = startValues.current;\n        const {\n          x: prevX,\n          y: prevY,\n          width: prevWidth,\n          height: prevHeight\n        } = prevValues.current;\n        const distX = Math.floor(enableX ? xSnapped - startX : 0);\n        const distY = Math.floor(enableY ? ySnapped - startY : 0);\n        let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);\n        let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);\n        if (keepAspectRatio) {\n          const nextAspectRatio = width / height;\n          const isDiagonal = enableX && enableY;\n          const isHorizontal = enableX && !enableY;\n          const isVertical = enableY && !enableX;\n          width = nextAspectRatio <= aspectRatio && isDiagonal || isVertical ? height * aspectRatio : width;\n          height = nextAspectRatio > aspectRatio && isDiagonal || isHorizontal ? width / aspectRatio : height;\n          if (width >= maxWidth) {\n            width = maxWidth;\n            height = maxWidth / aspectRatio;\n          } else if (width <= minWidth) {\n            width = minWidth;\n            height = minWidth / aspectRatio;\n          }\n          if (height >= maxHeight) {\n            height = maxHeight;\n            width = maxHeight * aspectRatio;\n          } else if (height <= minHeight) {\n            height = minHeight;\n            width = minHeight * aspectRatio;\n          }\n        }\n        const isWidthChange = width !== prevWidth;\n        const isHeightChange = height !== prevHeight;\n        if (invertX || invertY) {\n          const x = invertX ? startNodeX - (width - startWidth) : startNodeX;\n          const y = invertY ? startNodeY - (height - startHeight) : startNodeY;\n          // only transform the node if the width or height changes\n          const isXPosChange = x !== prevX && isWidthChange;\n          const isYPosChange = y !== prevY && isHeightChange;\n          if (isXPosChange || isYPosChange) {\n            const positionChange = {\n              id: node.id,\n              type: 'position',\n              position: {\n                x: isXPosChange ? x : prevX,\n                y: isYPosChange ? y : prevY\n              }\n            };\n            changes.push(positionChange);\n            prevValues.current.x = positionChange.position.x;\n            prevValues.current.y = positionChange.position.y;\n          }\n        }\n        if (isWidthChange || isHeightChange) {\n          const dimensionChange = {\n            id: id,\n            type: 'dimensions',\n            updateStyle: true,\n            resizing: true,\n            dimensions: {\n              width: width,\n              height: height\n            }\n          };\n          changes.push(dimensionChange);\n          prevValues.current.width = width;\n          prevValues.current.height = height;\n        }\n        if (changes.length === 0) {\n          return;\n        }\n        const direction = getDirection({\n          width: prevValues.current.width,\n          prevWidth,\n          height: prevValues.current.height,\n          prevHeight,\n          invertX,\n          invertY\n        });\n        const nextValues = _objectSpread(_objectSpread({}, prevValues.current), {}, {\n          direction\n        });\n        const callResize = shouldResize === null || shouldResize === void 0 ? void 0 : shouldResize(event, nextValues);\n        if (callResize === false) {\n          return;\n        }\n        onResize === null || onResize === void 0 || onResize(event, nextValues);\n        triggerNodeChanges(changes);\n      }\n    }).on('end', event => {\n      const dimensionChange = {\n        id: id,\n        type: 'dimensions',\n        resizing: false\n      };\n      onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd(event, _objectSpread({}, prevValues.current));\n      store.getState().triggerNodeChanges([dimensionChange]);\n    });\n    selection.call(dragHandler);\n    return () => {\n      selection.on('.drag', null);\n    };\n  }, [id, controlPosition, minWidth, minHeight, maxWidth, maxHeight, keepAspectRatio, getPointerPosition, onResizeStart, onResize, onResizeEnd]);\n  const positionClassNames = controlPosition.split('-');\n  const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n  const controlStyle = color ? _objectSpread(_objectSpread({}, style), {}, {\n    [colorStyleProp]: color\n  }) : style;\n  return React.createElement(\"div\", {\n    className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]),\n    ref: resizeControlRef,\n    style: controlStyle\n  }, children);\n}\nvar ResizeControl$1 = memo(ResizeControl);\nconst handleControls = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst lineControls = ['top', 'right', 'bottom', 'left'];\nfunction NodeResizer(_ref3) {\n  let {\n    nodeId,\n    isVisible = true,\n    handleClassName,\n    handleStyle,\n    lineClassName,\n    lineStyle,\n    color,\n    minWidth = 10,\n    minHeight = 10,\n    maxWidth = Number.MAX_VALUE,\n    maxHeight = Number.MAX_VALUE,\n    keepAspectRatio = false,\n    shouldResize,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  } = _ref3;\n  if (!isVisible) {\n    return null;\n  }\n  return React.createElement(React.Fragment, null, lineControls.map(c => React.createElement(ResizeControl$1, {\n    key: c,\n    className: lineClassName,\n    style: lineStyle,\n    nodeId: nodeId,\n    position: c,\n    variant: ResizeControlVariant.Line,\n    color: color,\n    minWidth: minWidth,\n    minHeight: minHeight,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    onResizeStart: onResizeStart,\n    keepAspectRatio: keepAspectRatio,\n    shouldResize: shouldResize,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd\n  })), handleControls.map(c => React.createElement(ResizeControl$1, {\n    key: c,\n    className: handleClassName,\n    style: handleStyle,\n    nodeId: nodeId,\n    position: c,\n    color: color,\n    minWidth: minWidth,\n    minHeight: minHeight,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    onResizeStart: onResizeStart,\n    keepAspectRatio: keepAspectRatio,\n    shouldResize: shouldResize,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd\n  })));\n}\nexport { ResizeControl$1 as NodeResizeControl, NodeResizer, ResizeControlVariant };","map":{"version":3,"names":["React","memo","useRef","useEffect","cc","drag","select","useNodeId","useStoreApi","useGetPointerPosition","clamp","ResizeControlVariant","getDirection","_ref","width","prevWidth","height","prevHeight","invertX","invertY","deltaWidth","deltaHeight","direction","initPrevValues","x","y","initStartValues","_objectSpread","pointerX","pointerY","aspectRatio","ResizeControl","_ref2","nodeId","position","variant","Handle","className","style","children","color","minWidth","minHeight","maxWidth","Number","MAX_VALUE","maxHeight","keepAspectRatio","shouldResize","onResizeStart","onResize","onResizeEnd","contextNodeId","id","store","resizeControlRef","startValues","prevValues","getPointerPosition","defaultPosition","Line","controlPosition","current","selection","enableX","includes","enableY","dragHandler","on","event","_node$width","_node$height","_node$position$x","_node$position$y","node","getState","nodeInternals","get","xSnapped","ySnapped","triggerNodeChanges","changes","startX","startY","startWidth","startHeight","startNodeX","startNodeY","prevX","prevY","distX","Math","floor","distY","nextAspectRatio","isDiagonal","isHorizontal","isVertical","isWidthChange","isHeightChange","isXPosChange","isYPosChange","positionChange","type","push","dimensionChange","updateStyle","resizing","dimensions","length","nextValues","callResize","call","positionClassNames","split","colorStyleProp","controlStyle","createElement","ref","ResizeControl$1","handleControls","lineControls","NodeResizer","_ref3","isVisible","handleClassName","handleStyle","lineClassName","lineStyle","Fragment","map","c","key","NodeResizeControl"],"sources":["/app/frontend/node_modules/@reactflow/node-resizer/dist/esm/index.mjs"],"sourcesContent":["import React, { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { drag } from 'd3-drag';\nimport { select } from 'd3-selection';\nimport { useNodeId, useStoreApi, useGetPointerPosition, clamp } from '@reactflow/core';\n\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\n\n// returns an array of two numbers (0, 1 or -1) representing the direction of the resize\n// 0 = no change, 1 = increase, -1 = decrease\nfunction getDirection({ width, prevWidth, height, prevHeight, invertX, invertY }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && invertX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && invertY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = useRef(null);\n    const startValues = useRef(initStartValues);\n    const prevValues = useRef(initPrevValues);\n    const getPointerPosition = useGetPointerPosition();\n    const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    useEffect(() => {\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        const selection = select(resizeControlRef.current);\n        const enableX = controlPosition.includes('right') || controlPosition.includes('left');\n        const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');\n        const invertX = controlPosition.includes('left');\n        const invertY = controlPosition.includes('top');\n        const dragHandler = drag()\n            .on('start', (event) => {\n            const node = store.getState().nodeInternals.get(id);\n            const { xSnapped, ySnapped } = getPointerPosition(event);\n            prevValues.current = {\n                width: node?.width ?? 0,\n                height: node?.height ?? 0,\n                x: node?.position.x ?? 0,\n                y: node?.position.y ?? 0,\n            };\n            startValues.current = {\n                ...prevValues.current,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.current.width / prevValues.current.height,\n            };\n            onResizeStart?.(event, { ...prevValues.current });\n        })\n            .on('drag', (event) => {\n            const { nodeInternals, triggerNodeChanges } = store.getState();\n            const { xSnapped, ySnapped } = getPointerPosition(event);\n            const node = nodeInternals.get(id);\n            if (node) {\n                const changes = [];\n                const { pointerX: startX, pointerY: startY, width: startWidth, height: startHeight, x: startNodeX, y: startNodeY, aspectRatio, } = startValues.current;\n                const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues.current;\n                const distX = Math.floor(enableX ? xSnapped - startX : 0);\n                const distY = Math.floor(enableY ? ySnapped - startY : 0);\n                let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);\n                let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);\n                if (keepAspectRatio) {\n                    const nextAspectRatio = width / height;\n                    const isDiagonal = enableX && enableY;\n                    const isHorizontal = enableX && !enableY;\n                    const isVertical = enableY && !enableX;\n                    width = (nextAspectRatio <= aspectRatio && isDiagonal) || isVertical ? height * aspectRatio : width;\n                    height = (nextAspectRatio > aspectRatio && isDiagonal) || isHorizontal ? width / aspectRatio : height;\n                    if (width >= maxWidth) {\n                        width = maxWidth;\n                        height = maxWidth / aspectRatio;\n                    }\n                    else if (width <= minWidth) {\n                        width = minWidth;\n                        height = minWidth / aspectRatio;\n                    }\n                    if (height >= maxHeight) {\n                        height = maxHeight;\n                        width = maxHeight * aspectRatio;\n                    }\n                    else if (height <= minHeight) {\n                        height = minHeight;\n                        width = minHeight * aspectRatio;\n                    }\n                }\n                const isWidthChange = width !== prevWidth;\n                const isHeightChange = height !== prevHeight;\n                if (invertX || invertY) {\n                    const x = invertX ? startNodeX - (width - startWidth) : startNodeX;\n                    const y = invertY ? startNodeY - (height - startHeight) : startNodeY;\n                    // only transform the node if the width or height changes\n                    const isXPosChange = x !== prevX && isWidthChange;\n                    const isYPosChange = y !== prevY && isHeightChange;\n                    if (isXPosChange || isYPosChange) {\n                        const positionChange = {\n                            id: node.id,\n                            type: 'position',\n                            position: {\n                                x: isXPosChange ? x : prevX,\n                                y: isYPosChange ? y : prevY,\n                            },\n                        };\n                        changes.push(positionChange);\n                        prevValues.current.x = positionChange.position.x;\n                        prevValues.current.y = positionChange.position.y;\n                    }\n                }\n                if (isWidthChange || isHeightChange) {\n                    const dimensionChange = {\n                        id: id,\n                        type: 'dimensions',\n                        updateStyle: true,\n                        resizing: true,\n                        dimensions: {\n                            width: width,\n                            height: height,\n                        },\n                    };\n                    changes.push(dimensionChange);\n                    prevValues.current.width = width;\n                    prevValues.current.height = height;\n                }\n                if (changes.length === 0) {\n                    return;\n                }\n                const direction = getDirection({\n                    width: prevValues.current.width,\n                    prevWidth,\n                    height: prevValues.current.height,\n                    prevHeight,\n                    invertX,\n                    invertY,\n                });\n                const nextValues = { ...prevValues.current, direction };\n                const callResize = shouldResize?.(event, nextValues);\n                if (callResize === false) {\n                    return;\n                }\n                onResize?.(event, nextValues);\n                triggerNodeChanges(changes);\n            }\n        })\n            .on('end', (event) => {\n            const dimensionChange = {\n                id: id,\n                type: 'dimensions',\n                resizing: false,\n            };\n            onResizeEnd?.(event, { ...prevValues.current });\n            store.getState().triggerNodeChanges([dimensionChange]);\n        });\n        selection.call(dragHandler);\n        return () => {\n            selection.on('.drag', null);\n        };\n    }, [\n        id,\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        getPointerPosition,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? { ...style, [colorStyleProp]: color } : style;\n    return (React.createElement(\"div\", { className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle }, children));\n}\nvar ResizeControl$1 = memo(ResizeControl);\n\nconst handleControls = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst lineControls = ['top', 'right', 'bottom', 'left'];\nfunction NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (React.createElement(React.Fragment, null,\n        lineControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: lineClassName, style: lineStyle, nodeId: nodeId, position: c, variant: ResizeControlVariant.Line, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd }))),\n        handleControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: handleClassName, style: handleStyle, nodeId: nodeId, position: c, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd })))));\n}\n\nexport { ResizeControl$1 as NodeResizeControl, NodeResizer, ResizeControlVariant };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}